<?xml version='1.0' encoding='UTF-8' standalone='yes'?>
<exception xmlns="http://bsi.bund.de/TR03151" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" id="ErrorTransactionLoggingNotLocked" xsi:schemaLocation="http://bsi.bund.de/TR03151 ../../schema/exceptions.xsd">
  <name>ErrorTransactionLoggingNotLocked</name>
  <description>This exception is thrown by the unlockTransactionLogging function if transaction logging functionality is not currently locked. The transaction logging system provides lock/unlock functionality to control when transactions can be recorded. The unlockTransactionLogging function is used to re-enable transaction recording after it has been locked for maintenance, audit, or security policy reasons. If unlockTransactionLogging is called when logging is already unlocked, ErrorTransactionLoggingNotLocked is raised to indicate the operation is invalid. ErrorTransactionLoggingNotLocked is a Medium severity exception because logging is already in the desired unlocked state, though the call itself is erroneous.</description>
  <category>Transaction Management</category>
  <subcategory>Logging Lock Management</subcategory>
  <severity>Medium</severity>
  <javadoc>
    <summary>This class defines the exception ErrorTransactionLoggingNotLocked that is thrown by the SE API function unlockTransactionLogging if transaction logging is not currently locked.</summary>
    <description>This exception is thrown when unlockTransactionLogging is called but transaction logging is not currently locked. Transaction logging provides lock/unlock functionality for administrative control. The unlockTransactionLogging function re-enables transaction recording after logging has been locked. If this function is called when logging is already unlocked, ErrorTransactionLoggingNotLocked is raised to indicate the operation is invalid. This prevents unnecessary unlock operations and alerts the caller that logging is not in the expected locked state. ErrorTransactionLoggingNotLocked is a Medium severity exception because logging is already operational, though the requested operation is erroneous. The caller should verify logging status before attempting to unlock.</description>
  </javadoc>
  <specification>
    <source>BSI TR-03151-1</source>
    <section>3.2.2 Transaction Management - Logging Control Functions</section>
    <requirement>The unlockTransactionLogging function re-enables transaction recording after logging has been locked. This function is used to exit lock states initiated by lockTransactionLogging or by security policy. If unlockTransactionLogging is called when transaction logging is not currently locked, the Secure Element SHALL raise ErrorTransactionLoggingNotLocked to indicate the operation is invalid. This prevents unnecessary unlock operations and alerts the caller that logging is not in the expected locked state. ErrorTransactionLoggingNotLocked is a Medium severity exception because logging is already operational and accessible. The caller should verify logging lock status before attempting unlock operations.</requirement>
    <applicability>Logging unlock operations: unlockTransactionLogging</applicability>
    <reference>Transaction Management (3.2.2), Logging Control Functions (3.2.2), unlockTransactionLogging – Function (3.2.2)</reference>
  </specification>
  <thrownBy>
    <function>unlockTransactionLogging</function>
  </thrownBy>
  <triggerConditions>
    <condition>
      <scenario>Unlock called when logging already unlocked</scenario>
      <description>unlockTransactionLogging called but logging is already in unlocked state</description>
      <trigger>Administrator calls unlockTransactionLogging but logging was never locked. Device detects logging is not locked and raises ErrorTransactionLoggingNotLocked.</trigger>
    </condition>
    <condition>
      <scenario>Multiple unlock attempts after initial unlock</scenario>
      <description>unlockTransactionLogging called multiple times sequentially</description>
      <trigger>First unlock succeeds and logging is re-enabled. Administrator attempts second unlock without rechecking status. Device detects logging not locked and raises ErrorTransactionLoggingNotLocked on second attempt.</trigger>
    </condition>
    <condition>
      <scenario>Unlock called after automatic lock expiration</scenario>
      <description>Temporary lock expires automatically before manual unlock attempted</description>
      <trigger>Logging locked for maintenance. Timer-based lock auto-expires and logging re-enables. Administrator attempts manual unlock. Device detects lock already expired (logging unlocked) and raises ErrorTransactionLoggingNotLocked.</trigger>
    </condition>
    <condition>
      <scenario>Unlock called after device reset resets lock state</scenario>
      <description>Device reset clears lock state before unlock attempted</description>
      <trigger>Logging locked for audit. Device restarts and clears temporary locks. Administrator attempts to unlock via command. Device detects logging not locked (reset cleared lock) and raises ErrorTransactionLoggingNotLocked.</trigger>
    </condition>
    <condition>
      <scenario>Unlock in error after lock status verification shows already unlocked</scenario>
      <description>Caller checks lock status, finds it unlocked, but requests unlock anyway in error</description>
      <trigger>Application checks logging lock status, receives already-unlocked response. Application incorrectly attempts unlock anyway. Device raises ErrorTransactionLoggingNotLocked due to status mismatch.</trigger>
    </condition>
  </triggerConditions>
  <executionSequence>
    <step number="1">User/application calls unlockTransactionLogging function</step>
    <step number="2">Function validates input parameters</step>
    <step number="3">Function initiates communication with Secure Element</step>
    <step number="4">Secure Element receives unlock transaction logging request</step>
    <step number="5">Secure Element checks transaction logging lock status</step>
    <step number="5a">If logging is locked → proceed to step 6</step>
    <step number="5b">If logging is not locked → ErrorTransactionLoggingNotLocked raised, operation aborted</step>
    <step number="6">Secure Element verifies authorization for unlock operation</step>
    <step number="6a">If authorization valid → proceed to step 7</step>
    <step number="6b">If authorization invalid → may raise ErrorParameterMismatch</step>
    <step number="7">Secure Element clears logging lock flag</step>
    <step number="8">Secure Element confirms logging now unlocked and operational</step>
    <step number="9">Secure Element returns success to function</step>
    <step number="10">Function returns to caller indicating logging successfully unlocked</step>
  </executionSequence>
  <recovery>
    <step>Transaction logging is already unlocked</step>
    <step>Locking may not be needed if already unlocked</step>
    <step>Verify intended lock state</step>
    <step>Check transaction logging configuration</step>
  </recovery>
  <relatedExceptions>
    <exception>ErrorTransactionLoggingLocked</exception>
    <exception>ErrorParameterMismatch</exception>
    <exception>ErrorFunctionFailed</exception>
    <exception>ErrorDeviceNotInitialized</exception>
  </relatedExceptions>
  <postconditionality>
    <state name="Logging Remains Unlocked">Logging is already unlocked and remains operational.</state>
    <state name="No State Change">Logging lock state is unchanged by operation.</state>
    <state name="Operation Not Executed">Unlock operation is not executed because logging not locked.</state>
    <state name="Medium Exception Returned">Function returns ErrorTransactionLoggingNotLocked Medium exception to caller.</state>
    <state name="Transactions Already Enabled">Transaction recording is already enabled - no change needed.</state>
    <state name="Caller Notified of Status">Caller receives notification that logging already unlocked.</state>
  </postconditionality>
  <notes>
    <note>Indication: Transaction logging is not locked when it should be - lock expected</note>
    <note>Topics: Transaction Logging, Logging Control, Lock Operations, State Validation</note>
  </notes>
  <usage>
    <scenario name="Scenario 1: Duplicate Unlock Attempt">
      <description>Administrator locks logging for maintenance, then manually unlocks it. After completing maintenance, administrator attempts unlock again without checking lock status. Device detects logging is already unlocked and raises ErrorTransactionLoggingNotLocked. Administrator reviews log and recognizes logging is already operational.</description>
      <relatedFunctions>unlockTransactionLogging, lockTransactionLogging</relatedFunctions>
      <errorContext>Duplicate unlock prevention - logging already operational</errorContext>
    </scenario>
    <scenario name="Scenario 2: Automatic Lock Expiration Before Manual Unlock">
      <description>Logging locked with 10-minute timeout for maintenance. Maintenance takes 5 minutes. Lock automatically expires and logging re-enables. Administrator then manually attempts unlock without checking status. Device detects logging not locked and raises ErrorTransactionLoggingNotLocked.</description>
      <relatedFunctions>unlockTransactionLogging, lockTransactionLogging</relatedFunctions>
      <errorContext>Automatic lock expiration prevents manual unlock need</errorContext>
    </scenario>
    <scenario name="Scenario 3: Device Reset Clears Temporary Lock">
      <description>Logging locked for audit preservation. Device unexpectedly restarts. Restart clears temporary locks (but preserves permanent policy locks). Administrator attempts to unlock via command, unaware of reset. Device detects logging already unlocked from reset and raises ErrorTransactionLoggingNotLocked.</description>
      <relatedFunctions>unlockTransactionLogging</relatedFunctions>
      <errorContext>Device reset clears temporary lock - manual unlock unnecessary</errorContext>
    </scenario>
    <scenario name="Scenario 4: Application Checks Status Before Unlock">
      <description>Application obtains logging lock status query, receives response indicating "not locked". Application receives error alert to attempt unlock. Application calls unlockTransactionLogging to ensure unlock. Device raises ErrorTransactionLoggingNotLocked due to already-unlocked status. Application error handling catches exception and continues normally.</description>
      <relatedFunctions>unlockTransactionLogging</relatedFunctions>
      <errorContext>Status check confirms unlock not needed - proper error handling</errorContext>
    </scenario>
  </usage>
  <implementationContext>
    <note>Raised by unlockTransactionLogging when logging not locked</note>
    <note>State validation expects transaction logging locked state</note>
    <note>Device prevents unlocking when logging already unlocked</note>
    <note>Unlocked state prevents unlock operation</note>
  </implementationContext>
</exception>

