<?xml version='1.0' encoding='UTF-8' standalone='yes'?>
<exception xmlns="http://bsi.bund.de/TR03151" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" id="ErrorCertificateExpired" xsi:schemaLocation="http://bsi.bund.de/TR03151 ../../schema/exceptions.xsd">
  <name>ErrorCertificateExpired</name>
  <description>This exception is thrown if a SE API function is invoked and the certificate corresponding to a private key used to create log messages is expired. Even if a certificate is expired, the log message SHALL be created by the Secure Element and stored by the device. In this case, the exception ErrorCertificateExpired SHALL be raised only after the data of the log message has been stored. This is a warning exception that indicates the operation succeeded but with a certificate validity concern.</description>
  <category>Certificate Management</category>
  <subcategory>Logging Operations</subcategory>
  <severity>Medium</severity>
  <javadoc>
    <summary>This class defines the exception ErrorCertificateExpired that is thrown if a SE API function is invoked and the certificate with the public key for the verification of the appropriate type of log messages is expired.</summary>
    <description>The ErrorCertificateExpired exception indicates that a function has successfully completed its primary operation (creating and storing a log message), but the certificate used for signing the log message has expired. Unlike typical exception scenarios where the operation fails, this exception is raised AFTER the log message has already been created and stored by the Secure Element. This design ensures that log messages are persisted even when the signing certificate is no longer valid, maintaining logging continuity. Applications should treat this as a warning condition indicating that certificate renewal or replacement may be necessary, while acknowledging that the log message operation succeeded. The expired certificate does not prevent logging but does indicate a potential security or compliance issue that requires attention.</description>
  </javadoc>
  <specification>
    <source>BSI TR-03151-1</source>
    <section>3.1.2.4 Exception Categories - Certificate Validity</section>
    <requirement>The exception SHALL be raised if a function is invoked and the certificate corresponding to a private key used to create log messages is expired. Even if a certificate is expired, the log message SHALL be created by the Secure Element and stored by the device. In this case, the exception ErrorCertificateExpired SHALL be raised only after the data of the log message has been stored. This ensures that logging continues despite certificate expiration, but the application is notified of the certificate validity issue.</requirement>
    <applicability>Functions that create log messages or perform logging operations when the signing certificate is no longer valid</applicability>
    <reference>BSI TR-03151-1 Section 3.1.2.4 - Exception Categories</reference>
  </specification>
  <thrownBy>
    <function>initialize</function>
    <function>setDescription</function>
    <function>selfTest</function>
    <function>updateDevice</function>
    <function>updateTime</function>
    <function>configureLogging</function>
    <function>registerClient</function>
    <function>deregisterClient</function>
    <function>startTransaction</function>
    <function>updateTransaction</function>
    <function>finishTransaction</function>
    <function>lockTransactionLogging</function>
    <function>unlockTransactionLogging</function>
  </thrownBy>
  <triggerConditions>
    <condition>
      <scenario>Log message creation with expired certificate</scenario>
      <description>Function performs logging operation while the certificate used for log message signing is expired (notAfter date has passed)</description>
      <trigger>During execution of a logging function, the Secure Element checks certificate validity. The certificate's expiration date (notAfter) is in the past. The Secure Element creates and signs the log message anyway, stores it successfully, and then signals this condition by allowing ErrorCertificateExpired to be raised.</trigger>
    </condition>
    <condition>
      <scenario>Multiple functions accessing expired certificate simultaneously</scenario>
      <description>Multiple logging functions may raise this exception if they all use the same expired certificate for log message signing</description>
      <trigger>Different logging functions (initialize, updateTime, startTransaction, etc.) all invoke log message creation while sharing an expired certificate. Each successful operation raises ErrorCertificateExpired.</trigger>
    </condition>
  </triggerConditions>
  <executionSequence>
    <step number="1">User/application calls a logging function (e.g., initialize, updateTime, finishTransaction, etc.)</step>
    <step number="2">Function performs its primary operation</step>
    <step number="3">Function requests log message creation from Secure Element</step>
    <step number="4">Secure Element checks certificate validity for log message signing</step>
    <step number="4a">If certificate is NOT expired → log message created and stored normally, no exception raised</step>
    <step number="4b">If certificate IS expired → continue anyway to ensure logging continuity</step>
    <step number="5">Secure Element creates and signs log message using expired certificate</step>
    <step number="6">Device stores the log message data successfully</step>
    <step number="7">Function raises ErrorCertificateExpired AFTER storage succeeds</step>
    <step number="8">Function returns to caller with exception and successful operation result</step>
  </executionSequence>
  <recovery>
    <step>Verify that operation succeeded despite the exception - log message was created and stored</step>
    <step>Identify the expired certificate from exception message or device logs</step>
    <step>Check certificate validity period to understand expiration timeline</step>
    <step>Plan certificate renewal or replacement to prevent persistent expiration</step>
    <step>Implement proactive certificate monitoring before expiration dates</step>
    <step>Review logging procedures to ensure continued operation during certificate transitions</step>
  </recovery>
  <relatedExceptions>
    <exception>ErrorFunctionFailed</exception>
    <exception>ErrorSigningEventDataFailed</exception>
    <exception>ErrorStoringLogMessageFailed</exception>
    <exception>ErrorSecureElementDisabled</exception>
  </relatedExceptions>
  <postconditionality>
    <state>Log message successfully created and stored - operation completed despite certificate expiration</state>
    <state>Exception raised AFTER storage succeeds - ensures log message persistence</state>
    <state>Certificate remains expired - no automatic renewal occurs</state>
    <state>Device state changed - log message now persisted in storage</state>
    <state>Signing certificate validity concern noted - application should plan for certificate management</state>
    <state>Function returns successfully to caller despite raising exception - log operation did not fail</state>
  </postconditionality>
  <notes>
    <note>Indication: A logging operation completed successfully, but the signing certificate has expired - operation succeeded despite certificate validity issue</note>
    <note>Topics: Certificate Management, Logging Operations, Certificate Validation, Secure Element Operations</note>
  </notes>
  <usage>
    <scenario name="Certificate Expiration Detection">
      <description>Catch ErrorCertificateExpired to detect when the logging certificate has expired and plan for renewal.</description>
      <example>try { device.updateTime(newTime); } catch (ErrorCertificateExpired e) { logger.warn("Logging certificate expired, schedule renewal: " + e.getMessage()); }</example>
    </scenario>
    <scenario name="Graceful Degradation">
      <description>Continue operation on ErrorCertificateExpired since the log message was stored successfully, but track the certificate issue.</description>
      <example>try { device.finishTransaction(txId); } catch (ErrorCertificateExpired e) { recordCertificateExpiration(e); continueProcessing(); }</example>
    </scenario>
    <scenario name="Certificate Management">
      <description>Use ErrorCertificateExpired as a trigger for certificate management procedures.</description>
      <example>catch (ErrorCertificateExpired e) { if (shouldRenewCertificate()) { device.updateCertificate(newCert); } }</example>
    </scenario>
    <scenario name="Audit Trail">
      <description>Log ErrorCertificateExpired occurrences for compliance and audit purposes.</description>
      <example>catch (ErrorCertificateExpired e) { auditLog.record("Certificate expired during logging: " + e.getMessage(), System.currentTimeMillis()); }</example>
    </scenario>
  </usage>
  <implementationContext>
    <note>Raised by logging functions when certificate validity check detects expiration</note>
    <note>Functions that create log messages (initialize, updateTime, startTransaction, etc.) perform certificate validation</note>
    <note>Device continues logging operation despite expired certificate to maintain audit trail integrity</note>
    <note>Application must implement certificate management to prevent persistent expiration conditions</note>
  </implementationContext>
</exception>

