<?xml version='1.0' encoding='utf-8'?>
<function xmlns="http://bsi.bund.de/TR03151" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" id="unblockPin" xsi:schemaLocation="http://bsi.bund.de/TR03151 ../../schema/functions.xsd">
  <name>unblockPin</name>
  <category>Authentifizierung</category>
  <description>Enables the unblocking for the entry of a PIN and the definition of a new PIN for the authentication of authorized users or applications.</description>
  <detailedSteps>
    <step>
      <number>1</number>
      <originalText>If the referencing guideline limits the access to the functionality solely to authenticated users, the function SHALL check if the user that has invoked the function has the status authenticated. If the status is not authenticated, the function SHALL raise the exception ErrorUserNotAuthenticated and exit the function.</originalText>
      <germanText>Falls die Richtlinie den Zugriff auf authentifizierte Benutzer beschränkt: Prüfe, ob der aufrufende Benutzer authentifiziert ist. Falls nicht: Werfe ErrorUserNotAuthenticated und beende Funktion.</germanText>
      <pseudocode>WENN Benutzer NICHT authentifiziert DANN
  WERFE ErrorUserNotAuthenticated
  BEENDE_FUNKTION
ENDE</pseudocode>
      <errorCase>
        <exception>ErrorUserNotAuthenticated</exception>
        <trigger>Der Benutzer ist nicht authentifiziert</trigger>
        <action>Funktion beenden</action>
      </errorCase>
    </step>
    <step>
      <number>2</number>
      <originalText>If the referencing guideline limits the access to the functionality to certain roles, the function SHALL check in the corresponding role if the (unauthenticated) user is authorized to execute the function. If the user is not authorized, the function SHALL raise the exception ErrorUserNotAuthorized and exit the function.</originalText>
      <germanText>Falls die Richtlinie den Zugriff auf bestimmte Rollen beschränkt: Prüfe in der entsprechenden Rolle, ob der (unauthentifizierte) Benutzer berechtigt ist, die Funktion auszuführen. Falls nicht: Werfe ErrorUserNotAuthorized und beende Funktion.</germanText>
      <pseudocode>WENN Benutzer NICHT autorisiert DANN
  WERFE ErrorUserNotAuthorized
  BEENDE_FUNKTION
ENDE</pseudocode>
      <errorCase>
        <exception>ErrorUserNotAuthorized</exception>
        <trigger>Der Benutzer ist nicht berechtigt</trigger>
        <action>Funktion beenden</action>
      </errorCase>
    </step>
    <step>
      <number>3</number>
      <originalText>The function SHALL check if the value for the passed userId is managed by the device. If the passed userId is not managed by the device, the function SHALL perform the tasks defined in chapter 3.2.5.5.1 to log the failed unblocking attempt. The element unblockResult SHALL be set to the value "unkownUserId". Afterwards the function SHALL raise the exception ErrorUnknownUserId and exit the function.</originalText>
      <germanText>Prüfe, ob die übergebene userId vom Gerät verwaltet wird. Falls nicht: Protokolliere fehlgeschlagenen Entsperr-Versuch (unblockResult="unknownUserId"), werfe ErrorUnknownUserId und beende Funktion.</germanText>
      <pseudocode>WENN userId NICHT vom Gerät verwaltet DANN
  RUFE_AUF Protokollierung fehlgeschlagener Versuch (unblockResult="unknownUserId")
  WERFE ErrorUnknownUserId
  BEENDE_FUNKTION
ENDE</pseudocode>
      <errorCase>
        <exception>ErrorUnknownUserId</exception>
        <trigger>Die userId wird vom Gerät nicht verwaltet</trigger>
        <action>Protokolliere Fehler, Funktion beenden</action>
      </errorCase>
    </step>
    <step>
      <number>4</number>
      <originalText>The function SHALL perform countermeasures against password guessing attacks. These countermeasures MAY be realized by delaying subsequent invocations of the function. If a password guessing attack is detected and the PUK is temporarily blocked as a countermeasure, the function SHALL perform the tasks defined in chapter 3.2.5.5.1 to log the failed unblocking attempt. The element unblockResult SHALL be set to the value "unblockingTemporarilyBlocked". Afterwards the function SHALL raise the exception ErrorPukTemporarilyBlocked and exit the function.</originalText>
      <germanText>Führe Schutzmechanismen gegen Wörterbuch-Anschläge durch. Falls PUK temporär gesperrt ist: Protokolliere fehlgeschlagenen Versuch (unblockResult="unblockingTemporarilyBlocked"), werfe ErrorPukTemporarilyBlocked und beende Funktion.</germanText>
      <pseudocode>WENN Anschlag erkannt UND PUK temporär gesperrt DANN
  RUFE_AUF Protokollierung fehlgeschlagener Versuch (unblockResult="unblockingTemporarilyBlocked")
  WERFE ErrorPukTemporarilyBlocked
  BEENDE_FUNKTION
ENDE</pseudocode>
      <errorCase>
        <exception>ErrorPukTemporarilyBlocked</exception>
        <trigger>PUK ist temporär gesperrt (Schutzmechanismus)</trigger>
        <action>Protokolliere Fehler, Funktion beenden</action>
      </errorCase>
    </step>
    <step>
      <number>5</number>
      <originalText>The function SHALL check if the passed PUK is correct for the passed userId. If the PUK is not correct, the function SHALL perform the actions defined in chapter 3.2.5.5.1 to log the failed unblocking attempt. The element unblockResult SHALL be set to the value "incorrectPuk". Afterwards the function SHALL raise the exception ErrorIncorrectPuk and exit the function.</originalText>
      <germanText>Prüfe, ob die übergebene PUK korrekt für die userId ist. Falls nicht: Protokolliere fehlgeschlagenen Versuch (unblockResult="incorrectPuk"), werfe ErrorIncorrectPuk und beende Funktion.</germanText>
      <pseudocode>WENN PUK NICHT korrekt DANN
  RUFE_AUF Protokollierung fehlgeschlagener Versuch (unblockResult="incorrectPuk")
  WERFE ErrorIncorrectPuk
  BEENDE_FUNKTION
ENDE</pseudocode>
      <errorCase>
        <exception>ErrorIncorrectPuk</exception>
        <trigger>Die PUK ist nicht korrekt</trigger>
        <action>Protokolliere Fehler, Funktion beenden</action>
      </errorCase>
    </step>
    <step>
      <number>6</number>
      <originalText>If the passed PUK is correct, the function SHALL perform the following tasks within one atomic transaction: (1) The function SHALL substitute the current PIN for the userId with the newPin. If this substitution fails, the function SHALL perform the actions defined in chapter 3.2.5.5.1 to log the failed unblocking attempt with unblockResult="errorSettingNewPinFailed" or generic "resettingError", and raise ErrorSettingNewPinFailed or ErrorUnblockingPinFailed. (2) The function SHALL set the PIN retry counter to the defined maximum value. If this fails, raise ErrorResettingRetryCounterFailed or ErrorUnblockingPinFailed with appropriate logging.</originalText>
      <germanText>Falls PUK korrekt ist: Führe folgende atomare Transaktionen durch: (1) Ersetze PIN durch newPin. Bei Fehler: Protokolliere mit unblockResult="errorSettingNewPinFailed" oder "resettingError", werfe ErrorSettingNewPinFailed oder ErrorUnblockingPinFailed. (2) Setze PIN-Wiederholungszähler auf Maximum. Bei Fehler: Protokolliere mit unblockResult="errorResettingRetryCounterFailed" oder "resettingError", werfe ErrorResettingRetryCounterFailed oder ErrorUnblockingPinFailed.</germanText>
      <pseudocode>VERSUCHE
  BEGINNE_TRANSAKTION atomare Operationen
  ERSETZE PIN durch newPin
  BEI_FEHLER_PIN
    RUFE_AUF Protokollierung (unblockResult="errorSettingNewPinFailed"/"resettingError")
    WERFE ErrorSettingNewPinFailed oder ErrorUnblockingPinFailed
    BEENDE_FUNKTION
  SETZE Wiederholungszähler auf Maximum
  BEI_FEHLER_ZÄHLER
    RUFE_AUF Protokollierung (unblockResult="errorResettingRetryCounterFailed"/"resettingError")
    WERFE ErrorResettingRetryCounterFailed oder ErrorUnblockingPinFailed
    BEENDE_FUNKTION
  COMMIT TRANSAKTION
  STELLE_SICHER Gerät ist konsistent
ENDE</pseudocode>
      <errorCase>
        <exception>ErrorSettingNewPinFailed</exception>
        <trigger>PIN-Ersetzung fehlgeschlagen</trigger>
        <action>Protokolliere Fehler, stelle Konsistenz sicher, Funktion beenden</action>
      </errorCase>
    </step>
    <step>
      <number>7</number>
      <originalText>The function SHALL invoke the functionality of the Secure Element to create the log message parts for the event data for the successful unblocking attempt. The element unblockResult SHALL be set to the value "success". If the execution of this Secure Element functionality fails, the function unblockPin SHALL raise the exception ErrorSigningEventDataFailed and exit the function.</originalText>
      <germanText>Rufe Secure-Element-Funktionalität auf, um Log-Nachricht-Teile für erfolgreiche Entsperrung zu erstellen (unblockResult="success"). Bei Fehler: Werfe ErrorSigningEventDataFailed und beende Funktion.</germanText>
      <pseudocode>VERSUCHE
  RUFE_AUF Secure-Element-Funktionalität
  SETZE unblockResult="success"
  HOLE Log-Nachricht-Teile vom SE
BEI_FEHLER
  WERFE ErrorSigningEventDataFailed
  BEENDE_FUNKTION
ENDE</pseudocode>
      <errorCase>
        <exception>ErrorSigningEventDataFailed</exception>
        <trigger>Secure-Element-Funktionalität fehlgeschlagen</trigger>
        <action>Funktion beenden</action>
      </errorCase>
    </step>
    <step>
      <number>8</number>
      <originalText>The function SHALL retrieve the parts of the log message determined by the Secure Element. If the retrieval of the log message parts fails, the function SHALL raise the exception ErrorRetrieveLogMessageFailed and exit the function.</originalText>
      <germanText>Hole die Log-Nachricht-Teile vom Secure Element. Falls der Abruf fehlschlägt: Werfe ErrorRetrieveLogMessageFailed und beende Funktion.</germanText>
      <pseudocode>VERSUCHE
  HOLE Log-Nachricht-Teile vom Secure Element
BEI_FEHLER
  WERFE ErrorRetrieveLogMessageFailed
  BEENDE_FUNKTION
ENDE</pseudocode>
      <errorCase>
        <exception>ErrorRetrieveLogMessageFailed</exception>
        <trigger>Abruf der Log-Nachricht-Teile fehlgeschlagen</trigger>
        <action>Funktion beenden</action>
      </errorCase>
    </step>
    <step>
      <number>9</number>
      <originalText>The function SHALL store the data of the previously retrieved log message parts on the storage medium. If the data has not been stored successfully, the function SHALL raise the exception ErrorStoringLogMessageFailed and exit the function.</originalText>
      <germanText>Speichere die Log-Nachricht-Teile auf dem Speichermedium. Falls Speicherung fehlschlägt: Werfe ErrorStoringLogMessageFailed und beende Funktion.</germanText>
      <pseudocode>VERSUCHE
  SPEICHERE Log-Nachricht-Teile auf Speichermedium
BEI_FEHLER
  WERFE ErrorStoringLogMessageFailed
  BEENDE_FUNKTION
ENDE</pseudocode>
      <errorCase>
        <exception>ErrorStoringLogMessageFailed</exception>
        <trigger>Speicherung auf Speichermedium fehlgeschlagen</trigger>
        <action>Funktion beenden</action>
      </errorCase>
    </step>
    <step>
      <number>10</number>
      <originalText>The function SHALL return without raising an exception to indicate that the execution of the function unblockPin has been successful.</originalText>
      <germanText>Gebe ohne Exception zurück, um erfolgreiche Ausführung anzuzeigen.</germanText>
      <pseudocode>RETURN ohne Exception
BEENDE_ERFOLGREICH</pseudocode>
      <successCase>
        <condition>Ausführung war erfolgreich</condition>
        <action>Funktion kehrt ohne Exception zurück</action>
      </successCase>
    </step>
  </detailedSteps>
  <parameters>
    <parameter>
      <name>userId</name>
      <type>String</type>
      <description>the ID of the user who or application that wants to unblock the corresponding PIN entry.</description>
      <direction>INPUT</direction>
      <required>true</required>
    </parameter>
    <parameter>
      <name>puk</name>
      <type>byte[]</type>
      <description>the PUK of the user/application.</description>
      <direction>INPUT</direction>
      <required>true</required>
    </parameter>
    <parameter>
      <name>newPin</name>
      <type>byte[]</type>
      <description>the new PIN for the user/application.</description>
      <direction>INPUT</direction>
      <required>true</required>
    </parameter>
  </parameters>
  <returnValue>
    <type>void</type>
    <description>This function does not return a value.</description>
  </returnValue>
  <exceptions>
    <exception>ErrorFunctionFailed</exception>
    <exception>ErrorFunctionNotSupported</exception>
    <exception>ErrorIncorrectPuk</exception>
    <exception>ErrorParameterSyntax</exception>
    <exception>ErrorParameterTooLong</exception>
    <exception>ErrorPukTemporarilyBlocked</exception>
    <exception>ErrorResettingRetryCounterFailed</exception>
    <exception>ErrorRetrieveLogMessageFailed</exception>
    <exception>ErrorSecureElementDisabled</exception>
    <exception>ErrorSecureElementPartsDisconnected</exception>
    <exception>ErrorSettingNewPinFailed</exception>
    <exception>ErrorSignatureCounterExhausted</exception>
    <exception>ErrorSignatureCounterOverflow</exception>
    <exception>ErrorSigningEventDataFailed</exception>
    <exception>ErrorStorageMediumDisconnected</exception>
    <exception>ErrorStorageMemoryFull</exception>
    <exception>ErrorStoringLogMessageFailed</exception>
    <exception>ErrorUnblockingPinFailed</exception>
    <exception>ErrorUnknownUserId</exception>
    <exception>ErrorUserNotAuthenticated</exception>
    <exception>ErrorUserNotAuthorized</exception>
  </exceptions>
  <systemLog>
    <logType>system</logType>
    <requirement>MUST</requirement>
    <asn1Structure>
      <logMessage>LogMessage ::= SEQUENCE {
  version                INTEGER (3),
  certifiedDataType      OBJECT IDENTIFIER (id-SE-API-system-log),
  certifiedData          SystemLogMessage,  -- embedded system log
  serialNumber           OCTET STRING (SIZE (32)),
  signatureAlgorithm     AlgorithmIdentifier,
  seAuditData            OCTET STRING OPTIONAL,
  signatureCounter       INTEGER,
  signatureCreationTime  Time,
  signatureValue         OCTET STRING
}</logMessage>
      <systemLogMessage>SystemLogMessage ::= SEQUENCE {
  version                    INTEGER (3),
  certifiedDataType          OBJECT IDENTIFIER (id-SE-API-system-log),
  eventType                  [0] IMPLICIT PrintableString ("unblockPin"),
  eventOrigin                [1] IMPLICIT PrintableString OPTIONAL,
  eventTriggeredByUser       [2] IMPLICIT UserId OPTIONAL,
  eventData                  [3] IMPLICIT UnblockPinEventData,
  additionalInternalData     [4] IMPLICIT OCTET STRING OPTIONAL,
  serialNumber               OCTET STRING (SIZE (32)),
  signatureAlgorithm         AlgorithmIdentifier,
  signatureCounter           INTEGER,
  signatureCreationTime      Time,
  signatureValue             OCTET STRING
}

UnblockPinEventData ::= SEQUENCE {
    userToUnblock  UserId,
    unblockResult  UnblockResult
}</systemLogMessage>
    </asn1Structure>
    <structure>
      <field>
        <name>version</name>
        <type>INTEGER (3)</type>
        <required>true</required>
        <defaultValue>3</defaultValue>
        <description>Version of the log message format. SHALL be set to '3'.</description>
        <origin>Provided by the device</origin>
      </field>
      <field>
        <name>certifiedDataType</name>
        <type>OBJECT IDENTIFIER</type>
        <required>true</required>
        <defaultValue>id-SE-API-system-log</defaultValue>
        <description>MUST be set to the OID id-SE-API-system-log.</description>
        <origin>Provided by the device</origin>
      </field>
      <field>
        <name>eventType</name>
        <type>PrintableString</type>
        <tag>[0] IMPLICIT</tag>
        <required>true</required>
        <defaultValue>unblockPin</defaultValue>
        <description>MUST be set to 'unblockPin'.</description>
        <origin>Provided by the device</origin>
      </field>
      <field>
        <name>eventOrigin</name>
        <type>PrintableString</type>
        <tag>[1] IMPLICIT</tag>
        <required>false</required>
        <description>Component that triggered the event (e.g., component name).</description>
        <origin>Provided by the device</origin>
      </field>
      <field>
        <name>eventTriggeredByUser</name>
        <type>UserId</type>
        <tag>[2] IMPLICIT</tag>
        <required>false</required>
        <description>User ID of the user that triggered the event.</description>
        <origin>Provided by the device</origin>
      </field>
      <field>
        <name>eventData</name>
        <type>UnblockPinEventData</type>
        <tag>[3] IMPLICIT</tag>
        <required>true</required>
        <description>Function-specific event data.</description>
        <origin>Provided by the device</origin>
      </field>
      <field>
        <name>additionalInternalData</name>
        <type>OCTET STRING</type>
        <tag>[4] IMPLICIT</tag>
        <required>false</required>
        <description>MUST NOT be present. Reserved for future use.</description>
        <note>RFU</note>
        <origin>-</origin>
      </field>
      <field>
        <name>serialNumber</name>
        <type>OCTET STRING (SIZE (32))</type>
        <required>true</required>
        <description>Serial number of the Secure Element consisting of the hash value of the public key of the certificate used to verify system logs.</description>
        <origin>Provided by the device</origin>
      </field>
      <field>
        <name>signatureAlgorithm</name>
        <type>AlgorithmIdentifier</type>
        <required>true</required>
        <description>Information about the signature creation.</description>
        <origin>Provided by the device</origin>
      </field>
      <field>
        <name>signatureCounter</name>
        <type>INTEGER</type>
        <required>true</required>
        <description>Current count of signatures created with the log message signing key protected by the Secure Element.</description>
        <origin>Provided by the Secure Element</origin>
      </field>
      <field>
        <name>signatureCreationTime</name>
        <type>Time</type>
        <required>true</required>
        <description>Point in time of the Secure Element when the log message was signed.</description>
        <origin>Provided by the Secure Element</origin>
      </field>
      <field>
        <name>signatureValue</name>
        <type>OCTET STRING</type>
        <required>true</required>
        <description>Result of the signature computation encoded as octet string.</description>
        <origin>Provided by the Secure Element</origin>
      </field>
    </structure>
  </systemLog>
</function>
